{
    "docs": [
        {
            "location": "/",
            "text": "tsrc - managing multiple git repositories\n\u00b6\n\n\nWhat it is\n\u00b6\n\n\ntsrc\n is a command-line tool that helps you manage several git repositories.\n\n\nWe use it at \ntanker.io\n because:\n\n\n\n\nWe have a small, versatile team of developers\n\n\nWe use several programming languages\n\n\nWe need a single source of truth for the list of repositories we want to work\n  on: their URL, branch and locations should be the same across all the team.\n\n\nNone on the many existing solutions did fully match our needs.\n  (see the \nFAQ\n for more details)\n\n\n\n\nIn addition, \ntsrc\n has some support for interaction with \nGitLab\n and makes\nhandling merge requests from the command line possible.\n\n\nInstalling tsrc\n\u00b6\n\n\ntsrc\n is compatible with \nPython 3.3\n or higher.\n\n\nIt is available on \npypi\n and can be\ninstalled with \npip\n:\n\n\nLinux\n\u00b6\n\n\n$ pip3 install tsrc --user\n# Make sure ~/.local/bin is in your PATH\n\n\n\n\nmacOS\n\u00b6\n\n\n$ pip3 install tsrc --user\n# Make sure ~/Library/Python/3.x/bin is in your PATH\n\n\n\n\nWindows\n\u00b6\n\n\nInstall latest Python3 from \npython.org/downloads\n,\nopen cmd.exe and run:\n\n\n$ pip3 install tsrc\n\n\n\n\nNext steps\n\u00b6\n\n\nIf \ntsrc\n is installed properly (check by running \ntsrc version\n), feel free to\nproceed to \nbasic usage\n.",
            "title": "Home"
        },
        {
            "location": "/#tsrc_-_managing_multiple_git_repositories",
            "text": "",
            "title": "tsrc - managing multiple git repositories"
        },
        {
            "location": "/#what_it_is",
            "text": "tsrc  is a command-line tool that helps you manage several git repositories.  We use it at  tanker.io  because:   We have a small, versatile team of developers  We use several programming languages  We need a single source of truth for the list of repositories we want to work\n  on: their URL, branch and locations should be the same across all the team.  None on the many existing solutions did fully match our needs.\n  (see the  FAQ  for more details)   In addition,  tsrc  has some support for interaction with  GitLab  and makes\nhandling merge requests from the command line possible.",
            "title": "What it is"
        },
        {
            "location": "/#installing_tsrc",
            "text": "tsrc  is compatible with  Python 3.3  or higher.  It is available on  pypi  and can be\ninstalled with  pip :",
            "title": "Installing tsrc"
        },
        {
            "location": "/#linux",
            "text": "$ pip3 install tsrc --user\n# Make sure ~/.local/bin is in your PATH",
            "title": "Linux"
        },
        {
            "location": "/#macos",
            "text": "$ pip3 install tsrc --user\n# Make sure ~/Library/Python/3.x/bin is in your PATH",
            "title": "macOS"
        },
        {
            "location": "/#windows",
            "text": "Install latest Python3 from  python.org/downloads ,\nopen cmd.exe and run:  $ pip3 install tsrc",
            "title": "Windows"
        },
        {
            "location": "/#next_steps",
            "text": "If  tsrc  is installed properly (check by running  tsrc version ), feel free to\nproceed to  basic usage .",
            "title": "Next steps"
        },
        {
            "location": "/guide/basics/",
            "text": "Basic tsrc usage\n\u00b6\n\n\nCloning a set of repositories\n\u00b6\n\n\ntsrc\n is driven by a manifest file that contains the names and paths of repositories to clone.\n\n\nIt uses the YAML syntax and looks like:\n\n\nrepos:\n  - src: foo\n    url: git@gitlab.local:acme/foo\n\n  - src: bar\n    url: git@gitlab.local:acme/bar\n\n\n\n\n\n\nNote\n\n\nThe full manifest file format is described in the \nreference\n.\n\n\n\n\nThe manifest must be put in a git repository too. You can then use the following commands to create a new workspace:\n\n\n$ mkdir ~/work\n$ cd work\n$ tsrc init git@gitlab.local:acme/manifest.git\n\n\n\n\nIn this example:\n\n\n\n\nA clone of the manifest repository will be created in a hidden \n.tsrc/manifest\n folder.\n\n\nfoo\n will be cloned in \n<work>/foo\n using \ngit@gitlab.com/acme/foo.git\n origin url.\n\n\nSimilarly, \nbar\n will be cloned in \n<work>/bar\n using \ngit@gitlab.com:acme/bar.git\n\n\n\n\nMaking sure all the repositories are up to date\n\u00b6\n\n\nYou can update all the repositories by using \ntsrc sync\n.\n\n\n\n\nThe manifest itself will be updated first.\n\n\nIf a new repository has been added to the manifest, it will be cloned.\n\n\nLastly, the other repositories will be updated.\n\n\n\n\nNote that \ntsrc sync\n only updates the repositories if the changes are trivial:\n\n\n\n\nIf the branch has diverged, \ntsrc\n will do nothing. It's up to you to use\n  \nrebase\n or \nmerge\n\n\nDitto if there is no remote tracking branch\n\n\n\n\n\n\nNote\n\n\nLike \ngit\n, tsrc will walk up the folders hierarchy looking for a \n.tsrc\n\nfolder, which means you can run tsrc commands anywhere in your workspace, not\njust at the top.",
            "title": "Basic usage"
        },
        {
            "location": "/guide/basics/#basic_tsrc_usage",
            "text": "",
            "title": "Basic tsrc usage"
        },
        {
            "location": "/guide/basics/#cloning_a_set_of_repositories",
            "text": "tsrc  is driven by a manifest file that contains the names and paths of repositories to clone.  It uses the YAML syntax and looks like:  repos:\n  - src: foo\n    url: git@gitlab.local:acme/foo\n\n  - src: bar\n    url: git@gitlab.local:acme/bar   Note  The full manifest file format is described in the  reference .   The manifest must be put in a git repository too. You can then use the following commands to create a new workspace:  $ mkdir ~/work\n$ cd work\n$ tsrc init git@gitlab.local:acme/manifest.git  In this example:   A clone of the manifest repository will be created in a hidden  .tsrc/manifest  folder.  foo  will be cloned in  <work>/foo  using  git@gitlab.com/acme/foo.git  origin url.  Similarly,  bar  will be cloned in  <work>/bar  using  git@gitlab.com:acme/bar.git",
            "title": "Cloning a set of repositories"
        },
        {
            "location": "/guide/basics/#making_sure_all_the_repositories_are_up_to_date",
            "text": "You can update all the repositories by using  tsrc sync .   The manifest itself will be updated first.  If a new repository has been added to the manifest, it will be cloned.  Lastly, the other repositories will be updated.   Note that  tsrc sync  only updates the repositories if the changes are trivial:   If the branch has diverged,  tsrc  will do nothing. It's up to you to use\n   rebase  or  merge  Ditto if there is no remote tracking branch    Note  Like  git , tsrc will walk up the folders hierarchy looking for a  .tsrc \nfolder, which means you can run tsrc commands anywhere in your workspace, not\njust at the top.",
            "title": "Making sure all the repositories are up to date"
        },
        {
            "location": "/guide/merge_requests/",
            "text": "Handling GitLab merge requests\n\u00b6\n\n\nConfiguration\n\u00b6\n\n\nThe first step is to log in to GitLab and get your personal access token.\n\n\nThen, write a file in \n~/.config/tsrc.yml\n containing the token:\n\n\nauth:\n  gitlab:\n    token: <your token>\n\n\n\n\n\n\nNote\n\n\nThe full config file format is described in the \nreference\n.\n\n\n\n\nThe second step is to tell \ntsrc\n about the HTTP url of your GitLab instance.\n\n\nThis is used to call the \nGitLab HTTP API\n (currently using version \n4\n)\n\n\nThis is done in the \nmanifest\n file:\n\n\ngitlab:\n  url: http://gitlab.local\n\nrepos:\n - ...\n\n\n\n\nCreating and accepting merge requests\n\u00b6\n\n\nHere's how you can create and assign a merge request\n\n\n# start working on your branch\n$ tsrc push [--assignee ASSIGNEE]\n\n\n\n\nWhen the review is done, you can accept it and let GitLab merge the branch once\nthe CI pipeline passes with the following command:\n\n\n$ tsrc push --accept",
            "title": "Handling GitLab merge requests"
        },
        {
            "location": "/guide/merge_requests/#handling_gitlab_merge_requests",
            "text": "",
            "title": "Handling GitLab merge requests"
        },
        {
            "location": "/guide/merge_requests/#configuration",
            "text": "The first step is to log in to GitLab and get your personal access token.  Then, write a file in  ~/.config/tsrc.yml  containing the token:  auth:\n  gitlab:\n    token: <your token>   Note  The full config file format is described in the  reference .   The second step is to tell  tsrc  about the HTTP url of your GitLab instance.  This is used to call the  GitLab HTTP API  (currently using version  4 )  This is done in the  manifest  file:  gitlab:\n  url: http://gitlab.local\n\nrepos:\n - ...",
            "title": "Configuration"
        },
        {
            "location": "/guide/merge_requests/#creating_and_accepting_merge_requests",
            "text": "Here's how you can create and assign a merge request  # start working on your branch\n$ tsrc push [--assignee ASSIGNEE]  When the review is done, you can accept it and let GitLab merge the branch once\nthe CI pipeline passes with the following command:  $ tsrc push --accept",
            "title": "Creating and accepting merge requests"
        },
        {
            "location": "/ref/cli/",
            "text": "Command line usage\n\u00b6\n\n\nImportant note\n\u00b6\n\n\nWe use the \nargparse\n library to\nparse command line arguments, so the \n--help\n messages are always up-to-date,\nprobably more so than this documentation :)\n\n\nGeneral\n\u00b6\n\n\ntsrc\n uses the same \"subcommand\" pattern as git does.\n\n\nOptions common to all commands are placed right before the command name.\n\n\nOptions after the command name only apply to this command.\n\n\nFor instance:\n\n\n$ tsrc --verbose sync\n$ tsrc init MANIFEST_URL\n\n\n\n\nGlobal options\n\u00b6\n\n\n\n\n--verbose\n\n\nshow verbose messages\n\n\n-q.--quiet\n\n\nhide everything except errors and warnings\n\n\n--color [always|never|auto]\n\n\ncontrol using color for messages (default 'auto', on if stdout is a terminal)\n\n\n\n\nUsage\n\u00b6\n\n\n\n\ntsrc init MANIFEST_URL [--group GROUP]\n\n\n\n\nInitializes a new workspace.\n\n\nMANIFEST_URL should be a git URL containing a valid\n\nmanifest.yml\n file.\n\n\nThe \n-g,-group\n can be used several times to specify which groups\nto use when cloning repositories.\n\n\nIf you want to add or remove a group in your workspace, you can\nre-run \ntsrc init\n\n\n\n\ntsrc foreach -- command --opt1 arg1\n\n\n\n\nRuns \ncommand --opt1 arg1\n in every repository, and report failures\nat the end.\n\n\nNote the \n--\n token to separate options for \ncommand\n from options for\n\ntsrc\n\n\n\n\ntsrc foreach -c 'command --opt1 arg1'\n\n\nDitto, but uses a shell. (\n/bin/sh\n on Linux or macOS, \ncmd.exe\n on Windows)\n\n\ntsrc log --from FROM [--to TO]\n\n\n\n\nDisplay a summary of all changes since \nFROM\n (should be a tag),\nto \nTO\n (defaulting to \nmaster\n)\n\n\nNote that if no changes are found, the repository will not be displayed at\nall.\n\n\n\n\ntsrc push [--assignee ASSIGNEE]\n\n\n\n\nYou should run this from a repository with the correct branch checked out.\n\n\n(The command will fail if you run this while on the \nmaster\n branch or in\n\"detached HEAD\" mode)\n\n\nASSIGNEE\n is optional and should match the name of an active GitLab user.\n\n\nThe merge request will get created if no other opened merge request with the same\nbranch exists. Otherwise, the existing merge request will be updated.\n\n\n\n\ntsrc push [--ready|--wip]\n\n\nToggle the \nWIP\n (\"Work In Progress\") prefix for the merge request.\n\n\ntsrc push --accept\n\n\n\n\nTell GitLab to merge the merge request after the CI has passed.\n\n\nNote that the source branch will get automatically removed. (Which should\nnot matter since all the information about the source branch will\nbe found in the merge commit)\n\n\n\n\ntsrc status\n\n\n\n\nDisplays a summary of the status of your workspace:\n\n\n\n\nShows dirty repos\n\n\nShows repos not on the expected branch\n\n\n\n\n\n\ntsrc sync\n\n\nUpdates all the repositories and shows a summary at the end.\n\n\ntsrc version\n\n\nDisplays \ntsrc\n version number, along additional data if run from a git clone.",
            "title": "Comand line usage"
        },
        {
            "location": "/ref/cli/#command_line_usage",
            "text": "",
            "title": "Command line usage"
        },
        {
            "location": "/ref/cli/#important_note",
            "text": "We use the  argparse  library to\nparse command line arguments, so the  --help  messages are always up-to-date,\nprobably more so than this documentation :)",
            "title": "Important note"
        },
        {
            "location": "/ref/cli/#general",
            "text": "tsrc  uses the same \"subcommand\" pattern as git does.  Options common to all commands are placed right before the command name.  Options after the command name only apply to this command.  For instance:  $ tsrc --verbose sync\n$ tsrc init MANIFEST_URL",
            "title": "General"
        },
        {
            "location": "/ref/cli/#global_options",
            "text": "--verbose  show verbose messages  -q.--quiet  hide everything except errors and warnings  --color [always|never|auto]  control using color for messages (default 'auto', on if stdout is a terminal)",
            "title": "Global options"
        },
        {
            "location": "/ref/cli/#usage",
            "text": "tsrc init MANIFEST_URL [--group GROUP]   Initializes a new workspace.  MANIFEST_URL should be a git URL containing a valid manifest.yml  file.  The  -g,-group  can be used several times to specify which groups\nto use when cloning repositories.  If you want to add or remove a group in your workspace, you can\nre-run  tsrc init   tsrc foreach -- command --opt1 arg1   Runs  command --opt1 arg1  in every repository, and report failures\nat the end.  Note the  --  token to separate options for  command  from options for tsrc   tsrc foreach -c 'command --opt1 arg1'  Ditto, but uses a shell. ( /bin/sh  on Linux or macOS,  cmd.exe  on Windows)  tsrc log --from FROM [--to TO]   Display a summary of all changes since  FROM  (should be a tag),\nto  TO  (defaulting to  master )  Note that if no changes are found, the repository will not be displayed at\nall.   tsrc push [--assignee ASSIGNEE]   You should run this from a repository with the correct branch checked out.  (The command will fail if you run this while on the  master  branch or in\n\"detached HEAD\" mode)  ASSIGNEE  is optional and should match the name of an active GitLab user.  The merge request will get created if no other opened merge request with the same\nbranch exists. Otherwise, the existing merge request will be updated.   tsrc push [--ready|--wip]  Toggle the  WIP  (\"Work In Progress\") prefix for the merge request.  tsrc push --accept   Tell GitLab to merge the merge request after the CI has passed.  Note that the source branch will get automatically removed. (Which should\nnot matter since all the information about the source branch will\nbe found in the merge commit)   tsrc status   Displays a summary of the status of your workspace:   Shows dirty repos  Shows repos not on the expected branch    tsrc sync  Updates all the repositories and shows a summary at the end.  tsrc version  Displays  tsrc  version number, along additional data if run from a git clone.",
            "title": "Usage"
        },
        {
            "location": "/ref/formats/",
            "text": "Configuration files formats\n\u00b6\n\n\nUnless otherwise noted, all configuration files use \nYAML\n\nsyntax\n\n\nManifest format\n\u00b6\n\n\nThe manifest is always parsed as a dictionary .\n\n\nTop fields\n\u00b6\n\n\n\n\n\n\nrepos\n (required): list of repos to clone\n\n\n\n\n\n\ngitlab.url\n (optional): HTTP URL of the GitLab instance\n\n\n\n\n\n\ngroups\n (optional): list of groups\n\n\n\n\n\n\nrepos\n\u00b6\n\n\nEach repository is also a dictionary, containing:\n\n\n\n\nsrc\n (required): relative path of the repository in the workspace\n\n\nurl\n (required): URL to use when cloning the repository (usually using ssh)\n\n\nbranch\n (optional): The branch to use when cloning the repository (defaults\n  to \nmaster\n)\n\n\n\n\nfixed_ref\n (optional): Can be a tag like \nv0.1\n or a hash like \n0ab12ef\n.\n   If \nfixed_ref\n is set:\n\n\n\n\nWhen running \ntsrc init\n: Project will be cloned with the given branch, and then reset to\n    the given ref.\n\n\nWhen running \ntsrc sync\n: If the project is clean, project will be reset\n    to the given ref, else a warning message will be printed.\n\n\n\n\n\n\n\n\ncopy\n: (optional): A list of dictionaries with \nsrc\n and \ndest\n keys, like so:\n\n\n\n\n\n\nrepos:\n  src: foo\n  url: gitlab:proj1/foo\n  branch: develop\n  copy:\n    - src: foo.txt\n      dest: top.txt\n\n\n\n\nIn this case, after \nproj1/foo\n has been cloned in \n<workspace>/foo\n,\n(using \ndevelop\n branch), \nfoo.txt\n will be copied from \nproj1/foo/foo.txt\n to\n\n<workspace>/top.txt\n. Note that \ncopy\n only works with files, not directories.\n\n\ngroups\n\u00b6\n\n\nThe \ngroups\n section lists the groups by name. They should contain a \nrepos\n field\ncontaining a list of repositories (which should match the sources of the repositories\ndefined in the \nrepos\n  section.\n\n\nThe groups can optionally include other groups, with a \nincludes\n field which should be\na list of existing group names.\n\n\nThe group named \ndefault\n, if it exists, will be used to know which repositories to clone\nwhen using \ntsrc init\n and the \n--group\n command line argument is not used.\n\n\nExample:\n\n\nrepos:\n  - src: a\n    url: ..\n  - src: b\n    url: ..\n  - src: bar\n    url: ..\n  - src: baz\n    url: ..\n\ngroups:\n  default:\n    repos: [a, b]\n  foo:\n    repos: [bar, baz]\n    includes: [default]\n\n\n\n\n$ tsrc init <manifest_url>\n# Clones a, b\n$ tsrc init <manifest_url> --group foo\n# Clones a, b, bar and baz\n\n\n\n\ntsrc.yml format\n\u00b6\n\n\ntsrc.yml\n must be written in \nXDG_CONFIG_HOME\n (or \n~/.config/\n).\n\n\nWe use GitLab authentication with token, like so:\n\n\nauth:\n  gitlab:\n    token: <your token>",
            "title": "Configuration files formats"
        },
        {
            "location": "/ref/formats/#configuration_files_formats",
            "text": "Unless otherwise noted, all configuration files use  YAML \nsyntax",
            "title": "Configuration files formats"
        },
        {
            "location": "/ref/formats/#manifest_format",
            "text": "The manifest is always parsed as a dictionary .",
            "title": "Manifest format"
        },
        {
            "location": "/ref/formats/#top_fields",
            "text": "repos  (required): list of repos to clone    gitlab.url  (optional): HTTP URL of the GitLab instance    groups  (optional): list of groups",
            "title": "Top fields"
        },
        {
            "location": "/ref/formats/#repos",
            "text": "Each repository is also a dictionary, containing:   src  (required): relative path of the repository in the workspace  url  (required): URL to use when cloning the repository (usually using ssh)  branch  (optional): The branch to use when cloning the repository (defaults\n  to  master )   fixed_ref  (optional): Can be a tag like  v0.1  or a hash like  0ab12ef .\n   If  fixed_ref  is set:   When running  tsrc init : Project will be cloned with the given branch, and then reset to\n    the given ref.  When running  tsrc sync : If the project is clean, project will be reset\n    to the given ref, else a warning message will be printed.     copy : (optional): A list of dictionaries with  src  and  dest  keys, like so:    repos:\n  src: foo\n  url: gitlab:proj1/foo\n  branch: develop\n  copy:\n    - src: foo.txt\n      dest: top.txt  In this case, after  proj1/foo  has been cloned in  <workspace>/foo ,\n(using  develop  branch),  foo.txt  will be copied from  proj1/foo/foo.txt  to <workspace>/top.txt . Note that  copy  only works with files, not directories.",
            "title": "repos"
        },
        {
            "location": "/ref/formats/#groups",
            "text": "The  groups  section lists the groups by name. They should contain a  repos  field\ncontaining a list of repositories (which should match the sources of the repositories\ndefined in the  repos   section.  The groups can optionally include other groups, with a  includes  field which should be\na list of existing group names.  The group named  default , if it exists, will be used to know which repositories to clone\nwhen using  tsrc init  and the  --group  command line argument is not used.  Example:  repos:\n  - src: a\n    url: ..\n  - src: b\n    url: ..\n  - src: bar\n    url: ..\n  - src: baz\n    url: ..\n\ngroups:\n  default:\n    repos: [a, b]\n  foo:\n    repos: [bar, baz]\n    includes: [default]  $ tsrc init <manifest_url>\n# Clones a, b\n$ tsrc init <manifest_url> --group foo\n# Clones a, b, bar and baz",
            "title": "groups"
        },
        {
            "location": "/ref/formats/#tsrcyml_format",
            "text": "tsrc.yml  must be written in  XDG_CONFIG_HOME  (or  ~/.config/ ).  We use GitLab authentication with token, like so:  auth:\n  gitlab:\n    token: <your token>",
            "title": "tsrc.yml format"
        },
        {
            "location": "/contrib/",
            "text": "Development\n\u00b6\n\n\nAll the development happens on \ngithub\n.\n\n\nOutcome of discussions among maintainers and users of the software are tracked in the \nwiki\n.\n\n\nReporting bugs and suggesting new features\n\u00b6\n\n\nFeel free to use \ngithub bug tracker\n to open issues.\n\n\nIf you are reporting a bug, please provide the following information:\n\n\n\n\ntsrc\n version\n\n\nDetails about your environment (operating system, Python version)\n\n\nThe exact command you run\n\n\nThe full output\n\n\n\n\nDoing so will ensure we can investigate your bug right away.\n\n\nSuggesting changes\n\u00b6\n\n\nYou are free to open a pull request on GitHub for any feature you'd like.\n\n\nBefore opening a merge request, please read the \ncode manifesto\n.\n\n\nNote that for your merge request to be accepted, we'll ask that:\n\n\n\n\nYou follow indications from the code manifesto\n\n\nAll existing linters pass\n\n\nAll existing tests run\n\n\nThe new feature comes with appropriate tests\n\n\n\n\nSee the \n.travis.yml file\n\nto see what exactly what commands are run and the Python versions we\nsupport.\n\n\nChecking your changes\n\u00b6\n\n\n\n\nCreate a virtualenv\n\n\nActivate it\n\n\nInstall development and documentation dependencies:\n\n\n\n\n$ pip install -r dev-requirements.txt\n$ pip install -r doc-requirements.txt\n\n\n\n\n\n\nFinally, run:\n\n\n\n\n$ python ci/ci.py\n\n\n\n\n\n\nUse \nif ... in ...\n when you can:\n\n\n\n\n# Yes\nif value in [\"option1\", \"option2\"]:\n   ...\n\n# No\nif value == \"option1\" or value == \"option2\"\n  ...",
            "title": "Contributing"
        },
        {
            "location": "/contrib/#development",
            "text": "All the development happens on  github .  Outcome of discussions among maintainers and users of the software are tracked in the  wiki .",
            "title": "Development"
        },
        {
            "location": "/contrib/#reporting_bugs_and_suggesting_new_features",
            "text": "Feel free to use  github bug tracker  to open issues.  If you are reporting a bug, please provide the following information:   tsrc  version  Details about your environment (operating system, Python version)  The exact command you run  The full output   Doing so will ensure we can investigate your bug right away.",
            "title": "Reporting bugs and suggesting new features"
        },
        {
            "location": "/contrib/#suggesting_changes",
            "text": "You are free to open a pull request on GitHub for any feature you'd like.  Before opening a merge request, please read the  code manifesto .  Note that for your merge request to be accepted, we'll ask that:   You follow indications from the code manifesto  All existing linters pass  All existing tests run  The new feature comes with appropriate tests   See the  .travis.yml file \nto see what exactly what commands are run and the Python versions we\nsupport.",
            "title": "Suggesting changes"
        },
        {
            "location": "/contrib/#checking_your_changes",
            "text": "Create a virtualenv  Activate it  Install development and documentation dependencies:   $ pip install -r dev-requirements.txt\n$ pip install -r doc-requirements.txt   Finally, run:   $ python ci/ci.py   Use  if ... in ...  when you can:   # Yes\nif value in [\"option1\", \"option2\"]:\n   ...\n\n# No\nif value == \"option1\" or value == \"option2\"\n  ...",
            "title": "Checking your changes"
        },
        {
            "location": "/code-manifesto/",
            "text": "Basics\n\u00b6\n\n\nWe use \npycodestyle\n to enforce a coding style matching \nPEP8\n.\n\n\nIn addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set \ncore.autocrlf\n to \ntrue\n in you git config file)\n\n\nPet peeves\n\u00b6\n\n\n\n\nPrefer double quotes for string literals\n\n\n\n\n# Yes\ndef bar():\n   \"\"\" bar stuff \"\"\"\n   a = \"foo\"\n\n\n# No\ndef bar():\n   ''' bar stuf '''\n   a = 'foo'\n\n# Exception\nmy_str = 'It contains some \"quotes\" inside'\n\n\n\n\n\n\nUse the fact that empty data structures are falsy:\n\n\n\n\n# Yes\nif not errors:\n    ...\n# No\nif len(errors) == 0:\n    ...\n\n\n\n\n\n\nDo not use \n+\n to build strings. Use \nformat()\n, \n%\n instead, or\n  \"f-strings\" if you only want the code to work with Python >= 3.6:\n\n\n\n\n# Yes\nmessage = \"Welcome, {}!\".format(name)\nmessage = \"Welcome, %s!\" % name\nmessage = f\"Welcome {name}!\"\n\n# No\nmessage = \"Welcome, \" + name + \"!\"\n\n# Okayish\nwith_ext = name + \".txt\"\n\n\n\n\n\n\nUse \ntextwrap.dedent()\n to build nice-looking multi-lines strings:\n\n\n\n\n# Yes\ndef foo():\n    long_message = textwrap.dedent(\"\"\"\\\n        first line\n        second line\n        third line\"\"\")\n\n# No\ndef foo():\n    long_message = \"\"\"\\\nfirst line\nsecond line\nthird line\n\"\"\"\n\n\n\n\n\n\nDo not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory)\n\n\n\n\n# Yes\nok, mess  = run_command()\n\nfor test_result in test_results:\n    outcome, message = res\n\n# No\nfoo, bar = False, \"\"\n\nclass Foo:\n    self.bar, self.baz = None, True\n\n\n\n\n\n\nDo not use conditional expressions. The order is not the same as the ternary operator in C++ and Javascript, so it should be avoided:\n\n\n\n\n# Yes\nif foo:\n   a = \"ok\"\nelse:\n   a = \"nope\"\n\n\n# No:\na = \"ok\" if foo else \"nope\"\n\n\n\n\nDoc strings and comments\n\u00b6\n\n\nFirst off, bad comments are worse that not comments.\n\n\nHowever by default, \npylint\n mandates that all public functions and methods (those that do not start with underscore) have a doc string. This is useful when you write a library, but for the code in \ntsrc\n this is useless and so we disable this rule in our \npylintrc\n.\n\n\nAlso note that you should use comments to explain \nwhy\n, never \nwhat\n. If the \nwhat\n is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead.\n\n\nIn conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful.\n\n\nCollections\n\u00b6\n\n\n\n\nUse .extend() instead of += to concatenate lists:\n\n\n\n\n# Yes\nlist_1.extend(list_2)\n\n# No\nlist_1 += list_2\n\n\n\n\n\n\nUse explicit methods to initialize lists and dictionaries. The code is more readable, and you have to use \nset()\n to initialize sets anyway:\n\n\n\n\n# Yes\nmy_list = list()\nmy_dict = dict()\n\n# No\nmy_list = []\nmy_dict = {}\n\n\n\n\n\n\nAlso use explicit call to list() in order to make a copy:\n\n\n\n\n# Yes\nmy_copy = list(my_list)\n\n# Also yes:\nmy_copy = copy.copy(my_list)\n\n# No\nmy_copy = my_list[:]\n\n\n\n\n\n\nUse list comprehensions instead of loops and \"functional\" methods:\n\n\n\n\n# Yes\nmy_list = [foo(x) for x in other_list]\n\n# No\nmy_list = list()\nfor x in other_list:\n     x.append(foo(x))\n\n# Also no\nmy_list = map(foo, other_list)\n\n# Yes\neven_nums = [x for x in nums if is_even(x)]\n\n# No\neven_numes = filter(is_even, nums)\n\n\n\n\n\n\nUse iterable syntax instead of building an explicit list:\n\n\n\n\n# Yes\nmax(len(x) for x in myiterable)\n\n# No\nmax([len(x) for x in myiterable])\n\n\n\n\n\n\nUse plural names for collections. This has the nice benefit of allowing you to have meaningful loop names:\n\n\n\n\nfor result in results:\n   # do something with result\n\n\n\n\nFunctions\n\u00b6\n\n\nPrefer using keyword-only parameters when possible:\n\n\n# Yes\n# If the parameter needs a default value:\ndef foo(bar, *, spam=True):\n    ...\n\n# If it does not:\ndef foo(bar, *, spam):\n    ...\n\n\n# No\ndef foo(bar, spam=True):\n    ...\n\n\n\n\nIf you use the last form, Python will let you use \nfoo(42, False)\n, and set \nspam\n to False.\nThis can cause problems if someone ever changes the \nfoo\n function and adds a new optional argument before \nspam\n:\n\n\ndef foo(bar, eggs=False, spam=Tue):\n    ...\n\n\n\n\nAfter such a change, the line \nfoo(42, False)\n which used to call \nfoo\n with \nspam=False\n now calls \nfoo\n with \nbar=False\n and \nspam=True\n, leading to all kind of interesting bugs.\n\n\nException to this rule: when the keyword is obvious and will not change:\n\n\ndef get(value, default=None):\n  ...\n\n\n\n\nImports\n\u00b6\n\n\nFor any \nfoo.py\n file, \nimport foo\n must never fail, unless there is a necessary module that could not be found. Do not catch  \nImportError\n unless it is necessary, for instance to deal with optional dependencies.\n\n\nimport required_module\n\nHAS_NICE_FEATURE = True\ntry:\n    import nicelib\nexcept ImportError:\n    HAS_NICE_FEATURE = False\n\n#...\n\nif HAS_NICE_FEATURE:\n    #....\n\n\n\n\n\n\n\n\nImporting Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a \nif __name__ == main() block\n.\n\n\n\n\n\n\nAlways use fully-qualified imports and names:\n\n\n\n\n\n\n# Yes\nimport foo.bar\nmy_bar = foo.bar.Bar()\n\n# No\nfrom foo import bar\nmy_bar = bar.Bar()\n\n\n\n\nBoth styles have pros and cons, we just need to be consistent here.\n\n\nClasses\n\u00b6\n\n\n\n\nWhen you want to make sure a class follows an interface, use \nabc.ABCMeta\n instead of raising \nNotImplementedError\n. This way you get the error when the class is instantiated instead of when the method is called.\n\n\n\n\n# Yes\nclass AbstractFoo(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def foo(self):\n        pass\n\n\n# No\nclass AbstractFoo:\n     def foo(self):\n        raise NotImplementedError()\n\n\n\n\n\n\n\nMake sure to use properties when relevant, instead of \nget_\n methods.\n\n\n\n\n# Yes\nclass Person:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n\n      @property\n      def full_name(self):\n          return \"{} {}\".format(self.first_name, self.last_name)\n\n\n# No:\nclass Foo:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n            self.full_name = \"{} {}\".format(self.first_name, self.last_name)\n\n\n\n\nFor instance, here:\n\n\n\n\nfull_name\n is read-only\n\n\nThe attribute is automatically updated if \nfirst_name\n changes after the object is initialized.\n\n\n\n\nNote that \nget_\n methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)\n\n\nFile paths\n\u00b6\n\n\n\n\nIf you are manipulating filenames, use the \npath.py\nlibrary and suffix the variable by \n_path\n. Avoid using \nos.path\n or \nshutil\n methods when \npath.py\n is better.\n\n\n\n\n# Yes\nwork_path = path.Path(\"foo/work\")\nwork_path.mkdir_p()\nfoo_path = work_path.joinpath(\"foo.txt\")\nfoo_path.write_text(\"this is bar\")\n\n# No\nwork_path = os.path.join(foo, \"work\")\nos.path.mkdir(work_path, exist_ok=True)\nfoo_path = os.path.join(work_path, \"foo.txt\")\nwith open(foo_path, \"w\") as fileobj:\n    fileobj.write(\"this is foo\")\n\n\n\n\nError handling\n\u00b6\n\n\n\n\nAll exceptions raised from within \ntsrc\n should derive from \ntsrc.Error\n.\n\n\nWhen using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them\n\n\n\n\nOutput messages to the user\n\u00b6\n\n\nDo not use \nprint\n, use \npython-cli-ui functions\n instead. This makes it easier to distinguish between real messages and the throw-away \nprint\ns you add for debugging.\n\n\nAlso, using \"high-level\" methods such as \nui.info_1()\n or \nui.warning()\n will make it easier to have a consistent user interface.",
            "title": "Code manifesto"
        },
        {
            "location": "/code-manifesto/#basics",
            "text": "We use  pycodestyle  to enforce a coding style matching  PEP8 .  In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set  core.autocrlf  to  true  in you git config file)",
            "title": "Basics"
        },
        {
            "location": "/code-manifesto/#pet_peeves",
            "text": "Prefer double quotes for string literals   # Yes\ndef bar():\n   \"\"\" bar stuff \"\"\"\n   a = \"foo\"\n\n\n# No\ndef bar():\n   ''' bar stuf '''\n   a = 'foo'\n\n# Exception\nmy_str = 'It contains some \"quotes\" inside'   Use the fact that empty data structures are falsy:   # Yes\nif not errors:\n    ...\n# No\nif len(errors) == 0:\n    ...   Do not use  +  to build strings. Use  format() ,  %  instead, or\n  \"f-strings\" if you only want the code to work with Python >= 3.6:   # Yes\nmessage = \"Welcome, {}!\".format(name)\nmessage = \"Welcome, %s!\" % name\nmessage = f\"Welcome {name}!\"\n\n# No\nmessage = \"Welcome, \" + name + \"!\"\n\n# Okayish\nwith_ext = name + \".txt\"   Use  textwrap.dedent()  to build nice-looking multi-lines strings:   # Yes\ndef foo():\n    long_message = textwrap.dedent(\"\"\"\\\n        first line\n        second line\n        third line\"\"\")\n\n# No\ndef foo():\n    long_message = \"\"\"\\\nfirst line\nsecond line\nthird line\n\"\"\"   Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory)   # Yes\nok, mess  = run_command()\n\nfor test_result in test_results:\n    outcome, message = res\n\n# No\nfoo, bar = False, \"\"\n\nclass Foo:\n    self.bar, self.baz = None, True   Do not use conditional expressions. The order is not the same as the ternary operator in C++ and Javascript, so it should be avoided:   # Yes\nif foo:\n   a = \"ok\"\nelse:\n   a = \"nope\"\n\n\n# No:\na = \"ok\" if foo else \"nope\"",
            "title": "Pet peeves"
        },
        {
            "location": "/code-manifesto/#doc_strings_and_comments",
            "text": "First off, bad comments are worse that not comments.  However by default,  pylint  mandates that all public functions and methods (those that do not start with underscore) have a doc string. This is useful when you write a library, but for the code in  tsrc  this is useless and so we disable this rule in our  pylintrc .  Also note that you should use comments to explain  why , never  what . If the  what  is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead.  In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful.",
            "title": "Doc strings and comments"
        },
        {
            "location": "/code-manifesto/#collections",
            "text": "Use .extend() instead of += to concatenate lists:   # Yes\nlist_1.extend(list_2)\n\n# No\nlist_1 += list_2   Use explicit methods to initialize lists and dictionaries. The code is more readable, and you have to use  set()  to initialize sets anyway:   # Yes\nmy_list = list()\nmy_dict = dict()\n\n# No\nmy_list = []\nmy_dict = {}   Also use explicit call to list() in order to make a copy:   # Yes\nmy_copy = list(my_list)\n\n# Also yes:\nmy_copy = copy.copy(my_list)\n\n# No\nmy_copy = my_list[:]   Use list comprehensions instead of loops and \"functional\" methods:   # Yes\nmy_list = [foo(x) for x in other_list]\n\n# No\nmy_list = list()\nfor x in other_list:\n     x.append(foo(x))\n\n# Also no\nmy_list = map(foo, other_list)\n\n# Yes\neven_nums = [x for x in nums if is_even(x)]\n\n# No\neven_numes = filter(is_even, nums)   Use iterable syntax instead of building an explicit list:   # Yes\nmax(len(x) for x in myiterable)\n\n# No\nmax([len(x) for x in myiterable])   Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names:   for result in results:\n   # do something with result",
            "title": "Collections"
        },
        {
            "location": "/code-manifesto/#functions",
            "text": "Prefer using keyword-only parameters when possible:  # Yes\n# If the parameter needs a default value:\ndef foo(bar, *, spam=True):\n    ...\n\n# If it does not:\ndef foo(bar, *, spam):\n    ...\n\n\n# No\ndef foo(bar, spam=True):\n    ...  If you use the last form, Python will let you use  foo(42, False) , and set  spam  to False.\nThis can cause problems if someone ever changes the  foo  function and adds a new optional argument before  spam :  def foo(bar, eggs=False, spam=Tue):\n    ...  After such a change, the line  foo(42, False)  which used to call  foo  with  spam=False  now calls  foo  with  bar=False  and  spam=True , leading to all kind of interesting bugs.  Exception to this rule: when the keyword is obvious and will not change:  def get(value, default=None):\n  ...",
            "title": "Functions"
        },
        {
            "location": "/code-manifesto/#imports",
            "text": "For any  foo.py  file,  import foo  must never fail, unless there is a necessary module that could not be found. Do not catch   ImportError  unless it is necessary, for instance to deal with optional dependencies.  import required_module\n\nHAS_NICE_FEATURE = True\ntry:\n    import nicelib\nexcept ImportError:\n    HAS_NICE_FEATURE = False\n\n#...\n\nif HAS_NICE_FEATURE:\n    #....    Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a  if __name__ == main() block .    Always use fully-qualified imports and names:    # Yes\nimport foo.bar\nmy_bar = foo.bar.Bar()\n\n# No\nfrom foo import bar\nmy_bar = bar.Bar()  Both styles have pros and cons, we just need to be consistent here.",
            "title": "Imports"
        },
        {
            "location": "/code-manifesto/#classes",
            "text": "When you want to make sure a class follows an interface, use  abc.ABCMeta  instead of raising  NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called.   # Yes\nclass AbstractFoo(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def foo(self):\n        pass\n\n\n# No\nclass AbstractFoo:\n     def foo(self):\n        raise NotImplementedError()   Make sure to use properties when relevant, instead of  get_  methods.   # Yes\nclass Person:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n\n      @property\n      def full_name(self):\n          return \"{} {}\".format(self.first_name, self.last_name)\n\n\n# No:\nclass Foo:\n      def __init__(self, first_name, last_name):\n            self.first_name = first_name\n            self.last_name = last_name\n            self.full_name = \"{} {}\".format(self.first_name, self.last_name)  For instance, here:   full_name  is read-only  The attribute is automatically updated if  first_name  changes after the object is initialized.   Note that  get_  methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)",
            "title": "Classes"
        },
        {
            "location": "/code-manifesto/#file_paths",
            "text": "If you are manipulating filenames, use the  path.py library and suffix the variable by  _path . Avoid using  os.path  or  shutil  methods when  path.py  is better.   # Yes\nwork_path = path.Path(\"foo/work\")\nwork_path.mkdir_p()\nfoo_path = work_path.joinpath(\"foo.txt\")\nfoo_path.write_text(\"this is bar\")\n\n# No\nwork_path = os.path.join(foo, \"work\")\nos.path.mkdir(work_path, exist_ok=True)\nfoo_path = os.path.join(work_path, \"foo.txt\")\nwith open(foo_path, \"w\") as fileobj:\n    fileobj.write(\"this is foo\")",
            "title": "File paths"
        },
        {
            "location": "/code-manifesto/#error_handling",
            "text": "All exceptions raised from within  tsrc  should derive from  tsrc.Error .  When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them",
            "title": "Error handling"
        },
        {
            "location": "/code-manifesto/#output_messages_to_the_user",
            "text": "Do not use  print , use  python-cli-ui functions  instead. This makes it easier to distinguish between real messages and the throw-away  print s you add for debugging.  Also, using \"high-level\" methods such as  ui.info_1()  or  ui.warning()  will make it easier to have a consistent user interface.",
            "title": "Output messages to the user"
        },
        {
            "location": "/faq/",
            "text": "Why not Python2 support?\n\u00b6\n\n\nWe believe Python2 is an inferior language than Python3, and we use many\nPython3 features to make the code more readable and robust.\n\n\nPlus \nPython2.7 supports ends in 2020\n.\n\n\nWhy not repo?\n\u00b6\n\n\nWe used \nrepo\n for a while, but\nfound that tsrc had both a better command line API and a nicer output.\n\n\nOn a less subjective level:\n\n\n\n\n\n\nGood support for Windows (no need for CygWin or anything like that)\n\n\n\n\n\n\nGitLab\n support (automate working with merge requests)\n\n\n\n\n\n\nLastly, tsrc tries hard to never do any destructive operation or unexpected\n  actions.\n\n\nFor instance, \ntsrc\n never puts you in a \"detached HEAD\" state,\nnor does automatic rebases. It also never touches dirty repos.\n\n\nThis is achieved by using mostly 'porcelain' commands from git, instead of\nrelying on plumbings internals.\n\n\n\n\n\n\nAlso (and this matters a lot if you think about contribution):\n\n\n\n\nComprehensive test suite\n\n\nUses PEP8 coding style\n\n\nWritten in Python 3, not Python 2\n\n\n\n\nHere are a few features present in repo that are missing from \ntsrc\n\n(but may be implemented in the future)\n\n\n\n\nCloning several repositories in parallel\n\n\nSupport for other hosting services such as \ngerrit\n or \ngithub\n\n\n\n\nWhy not git-subrepo, mu-repo, or gr?\n\u00b6\n\n\nAll this projects are fine but did not match our needs:\n\n\n\n\ngit-subrepo\n squashes commits, and\n  we prefer having normal clones everywhere\n\n\nmu-repo\n is nice and contains an\n  interesting dependency management feature, but currently we do not need this complexity.\n\n\n\n\nIn any case, now that the whole team is using \ntsrc\n all the time, it's likely\nwe'll keep using \ntsrc\n in the future.\n\n\nWhy not git submodule?\n\u00b6\n\n\nIt's all about workflow.\n\n\nWith \ngit-submodule\n, you have a 'parent' repository and you freeze the state of\nthe 'children' repositories to a specific commit.\n\n\nIt's useful when you want to re-build a library you've forked when you build\nyour main project, or when you have a library or build tools you want to\nfactorize across repositories: this means that each 'parent' repository can\nhave its children on any commit they want.\n\n\nWith \ntsrc\n, all repositories are equal, and what you do instead is to make sure\nall the branches (or tags) are consistent across repositories.\n\n\nFor instance, if you have \nfoo\n and \nbar\n, you are going to make sure the\n'master' branch of \nfoo\n is always compatible to the 'master' branch of \nbar\n.\n\n\nOr if you want to go back to the state of the '0.42' release, you will run:\n\ntsrc foreach -- git reset --hard v0.42\n.\n\n\nNote that since \ntsrc 0.2\n you can also freeze the commits of some of the\nrepositories.\n\n\nLast but not least, with \ntsrc\n you do everything with \ntsrc init\n and \ntsrc\nsync\n, which is a simpler command line API than \ngit submodule\n.\n\n\nWhy not using libgit2 or similar?\n\u00b6\n\n\npygit2\n now has pre-built wheels for Windows, but not for macOS and Linux.\n\n\nWe prefer to \nnot\n require compiling \nlibgit2\n.\n\n\nAlso, we prefer calling git \"porcelain\" commands, both for readability of the\nsource code and ease of debugging.\n\n\nWhy do you hide which git commands are run?\n\u00b6\n\n\nIt's mainly a matter of not cluttering the output.\nWe take care of keeping the output of \ntsrc\n both concise, readable and\ninformative.\n\n\nThat being said:\n\n\n\n\nIn case a git command fails, we'll display the full command that was run.\n\n\nIf you still need to see \nall\n the git commands that are run, we provide a\n  \n--verbose\n flag, like so: \ntsrc --verbose sync\n\n\n\n\nWhy argparse?\n\u00b6\n\n\nSee \ndocopt v argparse\n, and\n\nplease don't use click\n\n\nWhy YAML?\n\u00b6\n\n\nIt's nice to read and write, and we use the excellent \nruamel.yaml\n which even has round-trip support.\n\n\nAlso, being Python fans, we don't mind the whitespace constraints :P",
            "title": "FAQ"
        },
        {
            "location": "/faq/#why_not_python2_support",
            "text": "We believe Python2 is an inferior language than Python3, and we use many\nPython3 features to make the code more readable and robust.  Plus  Python2.7 supports ends in 2020 .",
            "title": "Why not Python2 support?"
        },
        {
            "location": "/faq/#why_not_repo",
            "text": "We used  repo  for a while, but\nfound that tsrc had both a better command line API and a nicer output.  On a less subjective level:    Good support for Windows (no need for CygWin or anything like that)    GitLab  support (automate working with merge requests)    Lastly, tsrc tries hard to never do any destructive operation or unexpected\n  actions.  For instance,  tsrc  never puts you in a \"detached HEAD\" state,\nnor does automatic rebases. It also never touches dirty repos.  This is achieved by using mostly 'porcelain' commands from git, instead of\nrelying on plumbings internals.    Also (and this matters a lot if you think about contribution):   Comprehensive test suite  Uses PEP8 coding style  Written in Python 3, not Python 2   Here are a few features present in repo that are missing from  tsrc \n(but may be implemented in the future)   Cloning several repositories in parallel  Support for other hosting services such as  gerrit  or  github",
            "title": "Why not repo?"
        },
        {
            "location": "/faq/#why_not_git-subrepo_mu-repo_or_gr",
            "text": "All this projects are fine but did not match our needs:   git-subrepo  squashes commits, and\n  we prefer having normal clones everywhere  mu-repo  is nice and contains an\n  interesting dependency management feature, but currently we do not need this complexity.   In any case, now that the whole team is using  tsrc  all the time, it's likely\nwe'll keep using  tsrc  in the future.",
            "title": "Why not git-subrepo, mu-repo, or gr?"
        },
        {
            "location": "/faq/#why_not_git_submodule",
            "text": "It's all about workflow.  With  git-submodule , you have a 'parent' repository and you freeze the state of\nthe 'children' repositories to a specific commit.  It's useful when you want to re-build a library you've forked when you build\nyour main project, or when you have a library or build tools you want to\nfactorize across repositories: this means that each 'parent' repository can\nhave its children on any commit they want.  With  tsrc , all repositories are equal, and what you do instead is to make sure\nall the branches (or tags) are consistent across repositories.  For instance, if you have  foo  and  bar , you are going to make sure the\n'master' branch of  foo  is always compatible to the 'master' branch of  bar .  Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 .  Note that since  tsrc 0.2  you can also freeze the commits of some of the\nrepositories.  Last but not least, with  tsrc  you do everything with  tsrc init  and  tsrc\nsync , which is a simpler command line API than  git submodule .",
            "title": "Why not git submodule?"
        },
        {
            "location": "/faq/#why_not_using_libgit2_or_similar",
            "text": "pygit2  now has pre-built wheels for Windows, but not for macOS and Linux.  We prefer to  not  require compiling  libgit2 .  Also, we prefer calling git \"porcelain\" commands, both for readability of the\nsource code and ease of debugging.",
            "title": "Why not using libgit2 or similar?"
        },
        {
            "location": "/faq/#why_do_you_hide_which_git_commands_are_run",
            "text": "It's mainly a matter of not cluttering the output.\nWe take care of keeping the output of  tsrc  both concise, readable and\ninformative.  That being said:   In case a git command fails, we'll display the full command that was run.  If you still need to see  all  the git commands that are run, we provide a\n   --verbose  flag, like so:  tsrc --verbose sync",
            "title": "Why do you hide which git commands are run?"
        },
        {
            "location": "/faq/#why_argparse",
            "text": "See  docopt v argparse , and please don't use click",
            "title": "Why argparse?"
        },
        {
            "location": "/faq/#why_yaml",
            "text": "It's nice to read and write, and we use the excellent  ruamel.yaml  which even has round-trip support.  Also, being Python fans, we don't mind the whitespace constraints :P",
            "title": "Why YAML?"
        },
        {
            "location": "/changelog/",
            "text": "v0.3.2 (2017-11-02)\n\u00b6\n\n\n\n\nImprove \ntsrc status\n to handle tags. Patch by @arnaudgelas\n\n\nFix crash when running \ntsrc version\n\n\n\n\nv0.3.1 (2017-10-06)\n\u00b6\n\n\n\n\nImprove \ntsrc status\n output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.\n\n\n\n\nv0.3.0 (2017-09-22)\n\u00b6\n\n\nBreaking change\n: Add support for groups (#30). Reported by @arnaudgelas.\n\n\nSee the \ndedicated section about manifest format\n for details.\n\n\nUpgrading from v0.2.4\n:\n\n\nTo upgrade from an older version of \ntsrc\n, you should re-run \ntsrc init\n with the correct url:\n\n\n# Check manifest URL:\n$ cd <workspace>/.tsrc/manifest\n$ git remote get-url origin\n# Note the url, for instance ssh://git@example.com:manifest.git\n$ cd <workspace>\n$ tsrc init <manifest-url>\n\n\n\n\nThis is required to create the \n<workspace>/.tsrc/manifest.yml\n file which is later used by \ntsrc sync\n and other commands.\n\n\nv0.2.4 (2017-07-13)\n\u00b6\n\n\n\n\ntsrc push --assignee\n: fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas\n\n\n\n\nv0.2.3 (2017-09-01)\n\u00b6\n\n\n\n\n\n\nSplit user interface functionality into its own project: \npython-cli-ui\n.\n\n\n\n\n\n\nAdd \n--quiet\n and \n--color\n global options.\n\n\n\n\n\n\nv0.2.2 (2017-08-22)\n\u00b6\n\n\nBug fix release.\n\n\n\n\ntsrc init\n: Fix crash when a repository is empty (#17). Reported by @nicolasbrechet\n\n\ntsrc push\n: Fix rude message when credentials are missing (#20). Reported by @cgestes\n\n\n\n\nv0.2.1 (2017-08-10)\n\u00b6\n\n\nPackaging fixes.\n\n\nv0.2.0 (2017-08-09)\n\u00b6\n\n\n\n\nSupport for specifying custom branches in the manifest\n\n\nSupport for specifying fixed refs (tags or hashes) in the manifest\n\n\n\n\nNew syntax is:\n\n\nrepos:\n  - src: foo\n    url: git@gitlab.com:proj/foo\n    branch: next\n\n  - src: bar\n    url: git@gitlab.com:proj/bar\n    branch: master\n    fixed_ref: v0.1\n\n\n\n\nNote that \nbranch\n is still required.\n\n\n\n\nYou can now skip the \ndest\n part of the \ncopy\n section if \nsrc\n and \ndest\n are\n  equal:\n\n\n\n\ncopy:\n  - src:foo\n\n# same thing as\ncopy:\n - src: foo\n   dest: foo\n\n\n\n\nv0.1.4 (2017-08-04)\n\u00b6\n\n\nSupport for Python 3.3, 3.4, 3.5 and 3.6\n\n\nv0.1.1 (2017-08-02)\n\u00b6\n\n\nFirst public release",
            "title": "Changelog"
        },
        {
            "location": "/changelog/#v032_2017-11-02",
            "text": "Improve  tsrc status  to handle tags. Patch by @arnaudgelas  Fix crash when running  tsrc version",
            "title": "v0.3.2 (2017-11-02)"
        },
        {
            "location": "/changelog/#v031_2017-10-06",
            "text": "Improve  tsrc status  output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.",
            "title": "v0.3.1 (2017-10-06)"
        },
        {
            "location": "/changelog/#v030_2017-09-22",
            "text": "Breaking change : Add support for groups (#30). Reported by @arnaudgelas.  See the  dedicated section about manifest format  for details.  Upgrading from v0.2.4 :  To upgrade from an older version of  tsrc , you should re-run  tsrc init  with the correct url:  # Check manifest URL:\n$ cd <workspace>/.tsrc/manifest\n$ git remote get-url origin\n# Note the url, for instance ssh://git@example.com:manifest.git\n$ cd <workspace>\n$ tsrc init <manifest-url>  This is required to create the  <workspace>/.tsrc/manifest.yml  file which is later used by  tsrc sync  and other commands.",
            "title": "v0.3.0 (2017-09-22)"
        },
        {
            "location": "/changelog/#v024_2017-07-13",
            "text": "tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas",
            "title": "v0.2.4 (2017-07-13)"
        },
        {
            "location": "/changelog/#v023_2017-09-01",
            "text": "Split user interface functionality into its own project:  python-cli-ui .    Add  --quiet  and  --color  global options.",
            "title": "v0.2.3 (2017-09-01)"
        },
        {
            "location": "/changelog/#v022_2017-08-22",
            "text": "Bug fix release.   tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet  tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes",
            "title": "v0.2.2 (2017-08-22)"
        },
        {
            "location": "/changelog/#v021_2017-08-10",
            "text": "Packaging fixes.",
            "title": "v0.2.1 (2017-08-10)"
        },
        {
            "location": "/changelog/#v020_2017-08-09",
            "text": "Support for specifying custom branches in the manifest  Support for specifying fixed refs (tags or hashes) in the manifest   New syntax is:  repos:\n  - src: foo\n    url: git@gitlab.com:proj/foo\n    branch: next\n\n  - src: bar\n    url: git@gitlab.com:proj/bar\n    branch: master\n    fixed_ref: v0.1  Note that  branch  is still required.   You can now skip the  dest  part of the  copy  section if  src  and  dest  are\n  equal:   copy:\n  - src:foo\n\n# same thing as\ncopy:\n - src: foo\n   dest: foo",
            "title": "v0.2.0 (2017-08-09)"
        },
        {
            "location": "/changelog/#v014_2017-08-04",
            "text": "Support for Python 3.3, 3.4, 3.5 and 3.6",
            "title": "v0.1.4 (2017-08-04)"
        },
        {
            "location": "/changelog/#v011_2017-08-02",
            "text": "First public release",
            "title": "v0.1.1 (2017-08-02)"
        }
    ]
}